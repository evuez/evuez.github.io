<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>evuez - Curried Elixir</title>

  <link rel="stylesheet" href="../styles.css">
</head>
<body>
  <header>
    <a href="https://git.k.mulga.net/julien">git</a> /
    <a href="mailto:hello@evuez.net">email</a>
  </header>
  <main>
    <a href="../index.html">index</a>
    <article>
      <h1>Curried Elixir</h1>
        <time datetime="2021-01-28">2021-01-28</time>
      <p>Elixir already supports <a href="https://evuez.net/posts/partially-applied-functions-in-elixir.html">partially applied functions</a> thanks to the <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#&amp;/1">capture operator</a>, and partial application is nice. But you know what's even better? <a href="https://evuez.net/posts/currying.html">Currying</a>!</p>
<p>Let's say we define this function:</p>
<pre><code>def my_fun(a, b, c) do
  a + b + c
end
</code></pre>
<p>What we would want is to have a <code>curry/1</code> function that would allow us transforming this function into a curried function:</p>
<pre><code>iex&gt; curried_fun = curry(&amp;my_fun/3)
iex&gt; curried_fun.(1).(2).(3)
6
iex&gt; add_42 = curried_fun.(40).(2)
iex&gt; add_42.(10)
52
</code></pre>
<p>We're going to do this by wrapping <code>my_fun</code> in a chain of anonymous functions, each binding exactly one name:</p>
<pre><code>curried_fun =
  fn (a) -&gt;
    fn (b) -&gt;
      fn (c) -&gt;
        my_fun.(a, b, c)
      end
    end
  end
</code></pre>
<p>The most (and only?) important thing we need to know in order to implement this <code>curry</code> function is the arity of the function we are given. We can use <a href="https://hexdocs.pm/elixir/master/Function.html#info/2"><code>Function.info/2</code></a> for this:</p>
<pre><code>iex&gt; Function.info(fn x, y -&gt; x * y end, :arity)
{:arity, 2}
</code></pre>
<p>Now that we have this, let's write this <code>curry</code> function!</p>
<pre><code>defmodule Func do
  def curry(fun) when is_function(fun) do
    {:arity, arity} = Function.info(fun, :arity)
    curry(fun, arity, [])
  end

  def curry(fun, 0, []), do: fn -&gt; fun.() end
  def curry(fun, 1, args), do: fn x -&gt; apply(fun, Enum.reverse([x | args])) end
  def curry(fun, arity, args), do: fn x -&gt; curry(fun, arity - 1, [x | args]) end
end
</code></pre>
<p>And that's it! Here's what happens when we're using <code>curry</code>:</p>
<pre><code>iex&gt; f = curry(&amp;Enum.map/2)
#Function&lt;...&gt; # fn x -&gt; curry(&amp;Enum.map/2, 1, [x]) end
iex&gt; f.(1..3)
#Function&lt;...&gt; # fn x -&gt; apply(&amp;Enum.map/2, Enum.reverse([x, 1..3])) end
iex&gt; f.(&amp;&quot;i = #{&amp;1}&quot;)
[&quot;i = 1&quot;, &quot;i = 2&quot;, &quot;i = 3&quot;] # apply(&amp;Enum.map/2, [1..3, &amp;&quot;i = #{&amp;1}&quot;])
</code></pre>
<p>0-arity functions are a special case, as we don't want <code>curry</code> to apply them for us, i.e.:</p>
<pre><code>iex&gt; curry(&amp;self/0)
#PID&lt;...&gt; # apply(&amp;self/0, [])
</code></pre>
<p>Instead, we wrap the function in a 0-arity anonymous function:</p>
<pre><code>iex&gt; f = curry(&amp;self/0)
#Function&lt;...&gt; # fn -&gt; apply(&amp;self/0, []) end
iex&gt; f.()
#PID&lt;...&gt; # apply(&amp;self/0, [])
</code></pre>

    </article>
  </main>
</body>
</html>
